#
# tablesnotebook.rb

#
# Este arquivo é parte do programa IPTEditor
# e é distribuído de acordo com a Licença Geral Pública do GNU - GPL
# This file is part of the IPTEditor program
# and is distributed under the terms of GNU General Public License - GPL
#
# Copyleft 2009, by angico.

#
# Dependências internas
require 'iptenotebook'
require 'rulespage'
require 'chainsnotebook'

class TablesNotebook < IPTENotebook
	attr_accessor :tabelas

	#
	def initialize(toggleButtons)
		super()
		@toggleButtons = toggleButtons
		
		$rulesLoaded = false
		addDefaultTabs
		$rulesLoaded = true
	end

	#
	# to_s
	# ----
	# retorna o conteúdo de todas as tabelas e cadeias como uma string,
	# no formato reconhecido por "iptables-restore" e "iptables-apply"
	#
	# return the contents of all tables and chains as a string, in the
	# format recognized by "iptables-restore" and "iptables-apply"
	#
	def to_s
		tabs = []
		datetime = Time.now
		
		each do |table|
			tabs << "# " + _("Generated by") + " IPTEditor v#{$versao} " + _("on") + " #{datetime}\n*#{table.name}\n"
			rules = ''
			table.each_with_index do |chain, i|
				pol = chain.policy == 'N/A' ? '-' : chain.policy
				tabs << ":#{chain.name} #{pol} [0:0]\n"
				rules += chain.to_s
			end
			tabs << rules
			tabs << "COMMIT\n# " + _("Completed on") + " #{datetime}\n"
		end
		
		tabs.compact.join
	end

	#
	# append_page
	# -----------
	# apensa uma página ao caderno de tabelas,
	# salvando o nome na variável "@paginas"
	#
	# appends a page to the tables notebook,
	# saving its name in the variable "@paginas"
	#
	def append_page(pagina, etq)
		puts "adicionando página #{etq.text} a #{name}" if $DEBUG
		
		super(pagina, etq)
		show_all
		
		@paginas << etq.text
		set_page @paginas.length - 1
	end
	
	#
	# text=
	# -----
	# inicializa as listas de acordo com o texto fornecido
	#
	# initializes lists according to the given text
	#
	def text=(s)
		$rulesLoaded = false

		clearTabs
		
		setApplied
		setSaved
		
		loadRules(s)

		$rulesLoaded = true
	end
	
	#
	# addDefaultTabs
	# --------------
	# cria as páginas iniciais (omissivas) dos cadernos de tabelas e de cadeias
	#
	# create initial (default) table and chain notebooks' pages
	#
	def addDefaultTabs
		defaultChains = {
			'filter' => ['INPUT', 'FORWARD', 'OUTPUT'],
			'mangle' => ['PREROUTING', 'INPUT', 'FORWARD', 'OUTPUT', 'POSTROUTING'],
			'nat'    => ['PREROUTING', 'OUTPUT', 'POSTROUTING'],
			'raw'    => ['PREROUTING', 'OUTPUT']
		}
		
		%w(filter mangle nat raw).each do |tab|
			etq = Label.new(tab)
			chainsNotebook = ChainsNotebook.new(tab)
			chainsNotebook.scrollable = true
			
			append_page(chainsNotebook, etq)
			
			defaultChains[tab].each {|chain| chainsNotebook.addChain(chain, 'ACCEPT', @toggleButtons) }
			
			chainsNotebook.setCurPage(0)
			chainsNotebook.signal_connect_after('switch_page') { @toggleButtons.call }
		end
		
	end
	
	#
	# clearTabs
	# ---------
	# zera as cadeias omissivas e remove as definidas pelo usuário
	#
	# clear default chains and remove user defined ones
	#
	def clearTabs
		each do |tab|
			tab.each_with_index do |ch, n|
				if ch.policy == 'N/A'
					tab.remove_page(n)
				else
					ch.clear
				end
			end
		end
	end
	
	#
	# loadRules
	# ---------
	# preenche as cadeias de cada tabela, criando novas conforme necessário
	#
	# fill out each table chain, creating new ones if necessary
	#
	def loadRules(text)
		chainsNotebook = pagina = pag = chain = nil
		cr = ''
		text.split(/\n/).each do |l|
			
			if l.start_with? '*'
				# linha inicia nova tabela
				# line starts a new table
				
				# reajusta página da tabela anterior
				# reset page of previous table
				chainsNotebook.setCurPage(0) if chainsNotebook
				
				# linha inicia nova tabela: selecionamos a página correspondente
				# line starts a new table: select the corresponding page
				pag = l.slice(1, l.length - 1)
				chainsNotebook = getPageForName(pag)
				
			else
				
				if l.start_with? ':'
					# linha inicia nova cadeia
					# this line starts a new chain
					ch, pol = l.slice(1, l.length - 1).split(/\s/)
					
					chainsNotebook.addChain(ch, pol, @toggleButtons)
					
				else
					
					if l.start_with? '-A'
						
						# linha de definição de regra
						# rule definition line
						r = l.split(/\s/)
						
						chain = chainsNotebook.setPageForName(r[1]) if ! chain || chain.name != r[1]

						# descartamos os dois primeiros campos (que são a instrução de apensamento da regra)
						# discard the first two fields (which are the rule's appending instruction)
						r = r.drop(2).join(' ')
						
						chainsNotebook.addRule(r)
					end
					
				end
				
			end
		end
		
		chainsNotebook.setCurPage(0) if chainsNotebook
		show_all
		
	end
	
	#
	# setApplied
	# ----------
	# limpa a indicação de não aplicado em todas as tabelas/cadeias
	#
	# clean the not applied indication for all tables/chains
	#
	def setApplied
		each_with_index do |tab, i|
			get_tab_label(get_nth_page(i)).applied
			tab.setApplied
		end
		
		$changed = false
	end
	
	#
	# setSaved
	# --------
	# limpa a indicação de não salvo em todas as tabelas/cadeias
	#
	# clean the not saved indication for all tables/chains
	#
	def setSaved
		each_with_index do |tab, i|
			get_tab_label(get_nth_page(i)).saved
			tab.setSaved
		end
		
		$changed = false
	end

end

#
# tablesnotebook.rb - eof
